<!DOCTYPE html>
<html>
<head>
    <title>Dijkstra Treasure Hunt</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
<div class="container">
    <h1>Dijkstra Treasure Hunt Game</h1>

    <div class="info-panel">
        <p>Start Node: <span id="start">{{start}}</span></p>
        <p>Goal Node: <span id="goal">{{treasure}}</span></p>
        <p>Current Node: <span id="current">{{start}}</span></p>
        <p>Total Cost: <span id="cost">0</span></p>
        <p>Visited Path: <span id="visited">{{start}}</span></p>
    </div>

    <canvas id="graphCanvas" width="700" height="450"></canvas>

    <div class="buttons">
        <button onclick="resetGame()">Reset Game</button>
    </div>

    <pre id="output"></pre>
</div>

<script>
const canvas = document.getElementById("graphCanvas");
const ctx = canvas.getContext("2d");

const positions = {{ positions|tojson }};
const graph = {{ graph|tojson }};
const startNode = "{{start}}";
const goalNode = "{{treasure}}";

let currentNode = startNode;
let carPos = {...positions[startNode]};
const speed = 3;
let optimalPath = []; // store optimal path for drawing

function drawGraph() {
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // Draw edges
    for (let from in graph) {
        for (let to in graph[from]) {
            ctx.beginPath();
            ctx.moveTo(...positions[from]);
            ctx.lineTo(...positions[to]);

            // Highlight optimal path edges
            if(optimalPath.length > 0){
                for(let i=0;i<optimalPath.length-1;i++){
                    if( (from===optimalPath[i] && to===optimalPath[i+1]) || 
                        (from===optimalPath[i+1] && to===optimalPath[i]) ){
                        ctx.strokeStyle = "#f1c40f"; // gold
                        ctx.lineWidth = 5;
                        ctx.stroke();
                        continue;
                    }
                }
            }

            ctx.strokeStyle = "#aaa";
            ctx.lineWidth = 3;
            ctx.stroke();

            // edge weight
            const midX = (positions[from][0]+positions[to][0])/2;
            const midY = (positions[from][1]+positions[to][1])/2;
            ctx.fillStyle = "#222";
            ctx.font = "16px Arial";
            ctx.fillText(graph[from][to], midX-8, midY-8);
        }
    }

    // Draw nodes
    for (let node in positions) {
        ctx.beginPath();
        ctx.arc(...positions[node], 25, 0, Math.PI*2);
        if(node===currentNode) ctx.fillStyle = "#e74c3c";
        else if(node===goalNode) ctx.fillStyle = "#27ae60";
        else ctx.fillStyle = "#3498db";
        ctx.shadowColor = "#888";
        ctx.shadowBlur = 6;
        ctx.fill();
        ctx.strokeStyle = "#222";
        ctx.lineWidth = 2;
        ctx.stroke();

        // highlight nodes in optimal path
        if(optimalPath.includes(node)){
            ctx.strokeStyle = "#f1c40f";
            ctx.lineWidth = 4;
            ctx.stroke();
        }

        ctx.fillStyle = "#fff";
        ctx.font = "18px Arial";
        ctx.fillText(node, positions[node][0]-6, positions[node][1]+6);
    }

    // Draw player
    ctx.beginPath();
    ctx.arc(carPos.x, carPos.y, 12, 0, Math.PI*2);
    ctx.fillStyle = "#f39c12";
    ctx.fill();
    ctx.strokeStyle = "#e67e22";
    ctx.lineWidth = 2;
    ctx.stroke();
}

canvas.addEventListener("click", (e)=>{
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    for(let node in positions){
        const dx = x-positions[node][0];
        const dy = y-positions[node][1];
        if(Math.sqrt(dx*dx+dy*dy)<25 && graph[currentNode][node]){
            moveTo(node);
        }
    }
});

async function moveTo(node){
    const res = await fetch("/move", {
        method:"POST",
        headers:{"Content-Type":"application/json"},
        body: JSON.stringify({choice: node})
    });
    const data = await res.json();

    const target = positions[node];
    const dx = target[0]-carPos.x;
    const dy = target[1]-carPos.y;
    const distance = Math.sqrt(dx*dx+dy*dy);
    const steps = distance/speed;
    let step = 0;

    function animate(){
        if(step<steps){
            carPos.x += dx/steps;
            carPos.y += dy/steps;
            drawGraph();
            step++;
            requestAnimationFrame(animate);
        } else {
            carPos.x = target[0];
            carPos.y = target[1];
            currentNode = node;
            drawGraph();

            document.getElementById("current").innerText = currentNode;
            document.getElementById("cost").innerText = data.total_cost || 0;
            document.getElementById("visited").innerText = data.visited ? data.visited.join(" -> ") : currentNode;

            if(data.game_over){
                optimalPath = data.optimal_path;
                drawGraph();
                document.getElementById("output").innerText =
                    `Your path: ${data.visited.join(" -> ")}\n` +
                    `Your cost: ${data.total_cost}\n\n` +
                    `Optimal path: ${data.optimal_path.join(" -> ")}\n` +
                    `Optimal cost: ${data.optimal_cost}`;
                alert("You reached the treasure! Optimal path is now highlighted.");
            }
        }
    }
    animate();
}

async function resetGame(){
    await fetch("/reset");
    currentNode = startNode;
    carPos = {...positions[startNode]};
    optimalPath = [];
    drawGraph();
    document.getElementById("current").innerText = currentNode;
    document.getElementById("cost").innerText = 0;
    document.getElementById("visited").innerText = startNode;
    document.getElementById("output").innerText = "";
}

drawGraph();
</script>
</body>
</html>
